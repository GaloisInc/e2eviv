\chapter{Crypto Specification\ifdraft{(Aggelos, Joe) (100\%)}{}}
\label{chapter:crypto_spec}

No existing E2E-VIV system or E2E-V protocol fulfills the requirements
set forth in this report. Therefore, we cannot provide a full
cryptographic system or protocol specification.  The development and
verification of such a specification would be one of the primary
deliverables of a phase two of this project.

In order to frame that speculative future research, a formalized ideal
functionality for an E2E-V system is a useful foundation for examining
and comparing E2E-V protocols. This chapter provides such a foundation.

This chapter also discusses the set of technologies that should be
used to mechanize and verify E2E-V protocols and their cryptographic
algorithms. Mechanization and formal verification is mandatory for any
E2E-V protocol that will be used in public elections.

\section{Crypto Specification}

Cryptographic specifications are typically written ``on paper'' in
peer-reviewed articles. With increasing frequency, algorithms and
protocols are mechanized, either within general-purpose logic
frameworks such as Coq~\cite{Coq} or in specialized environments such
as EasyCrypt~\cite{EasyCrypt}. The foundations discussed in the
following sections have not yet been mechanized, but must be as a
first step toward any future E2E-V protocol development. A discussion of
the best practices for such mechanization and verification is included
in~\autoref{sec:crypto_mechanization}.

\subsection{Ideal Functionality of an E2E-V System}

In this section we introduce a template for expressing the core of an
E2E-V system as an ideal functionality. An ideal
functionality is an abstraction that expresses the I/O interfaces of
the system with the parties that are involved in the e-voting process
as well as the way the system is supposed to react to inputs. The
ideal functionality specification also includes an I/O interface with
the adversary, which expresses precisely the type of information that
is leaked to the adversary (the output channel of the interface) and
the level of influence the adversary may have on the actions taken by
the functionality (the input channel of the interface).

The ideal functionality is supposed to operate in an \emph{ideal
  world}, where parties have direct access to its interfaces. This
means that the adversary is not able to block or manipulate the
communications between other parties and the ideal functionality. The
only way for the adversary to interfere is through its own
interface. This emphasizes that the ideal functionality has precedence
over the adversary in the ideal world. In the real world, such an
ideal functionality does not exist; parties have to resort to the
execution of a protocol that intends to implement the ideal
functionality in reality. The conditions under which a protocol can be
said to realize an ideal functionality are explained below.

The intent of the ideal functionality is to express, succinctly and in
tandem, all the required properties of a system. A protocol is said to
realize an ideal functionality if it is possible to translate any
attack in the real world to an attack in the ideal world in a way such
that, no matter how the system is operated by the parties, it is
impossible to achieve any distinguishing effect between the two
worlds. This indistinguishability property is the hallmark of a safe
implementation of the ideal functionality. Establishing it requires a
\emph{security proof} that is constructive and algorithmic in
nature. Given any real world adversary, an ideal world adversary
(usually referred to as the \emph{simulator}) is constructed that
achieves the above indistinguishability property.

An ideal functionality operates in the context of an ideal world
execution, a simulation that involves the following parties: the
functionality itself, the environment and the adversary. The
environment is the main driver of the execution that describes the
sequence of actions that take place in the interfaces of the ideal
functionality. It is helpful to think of these actions as serialized;
however, formulations of concurrent executions are also possible. The
environment is not concerned with how the ideal functionality
operates, as it only provides input and receives output from the
interfaces of the functionality. At the same time, the environment
communicates with the adversary in some arbitrary unrestricted
fashion; no assumptions are made about the interface between the
environment and the ideal functionality. This unrestricted
communcation with the environment is essential to ensure that the
election system may be arbitrarily composed within larger systems that
involve other components. If the interface between environment and
adversary is specified and restricted in some way, it typically
becomes simpler to realize the functionality; however, this may
sacrifice the composability of the protocol.

We provide only a template for an ideal functionality for E2E-V. This
emphasizes the fact that further research will be required to
establish a precise formulation of this ideal
functionality. Furthermore there could be many different versions of
the ideal functionality capturing similar but potentially different
facets of the e-voting design problem.

\subsubsection{Interfaces of the Ideal Functionality}

The interfaces of the E2E-V ideal functionality are described
below. These are given to parties that the ideal functionality is able
to identify. Some interfaces may be given to any party, without the
functionality being concerned about the identity of that party.

The \emph{administrator interface} is provided to the administrator of
the election system.  It enables the administrator to set up an
election, an action that involves the description of the ballot and
any restrictions and constraints that need to be applied to the ballot
casting phase (e.g., how many and what choices are valid per
question). The initialization message should specify the type of
election function (e.g., a plurality vote) that should be applied to
the inputs collected from the voters as well as the list of eligible
voters, which should be a subset of the parties that the functionality
is able to identify. The administrator is also responsible for opening
and closing the polls.

The \emph{voter interface} is provided to the voters. It allows a
voter to cast a vote for the election that is controlled by the ideal
functionality as long as the election is open. The interface is also
able to return some feedback to the voter, which will enable the voter
to verify that her vote has been correctly recorded and included in
the final tally.

The \emph{auditor interface} is provided to any interested party.  It
allows auditing of the election result and of the election process in
general. The auditor interface makes public all information about the
election, including the list of eligible voters. Furthermore, after the
closing of the polls, this interface allows voters to verify that
their votes were correctly recorded and included in the final tally. 

The \emph{adversary interface} enables the adversary to learn and
influence how the ideal functionality operates in a number of ways. It
enables the adversary to corrupt any party that is involved in the
process. Corrupted parties are assumed to be under the control of the
adversary. The identities of corrupted parties are kept by the ideal
functionality, which may modify its operation depending on which
parties are corrupted. Most importantly, in case of a corrupted
administrator, the ideal functionality will allow the modification of
votersâ€™ submitted votes.

\subsubsection{Ideal Functionality}

The following is a general template describing how the functionality
reacts when receiving input from any of its available interfaces. This
should be interpreted as a general guide for expressing the syntax and
properties of an ideal functionality for an E2E-V system, rather than
as a definitive final formulation. Using this template as a basis, a
number of different functionalities may be derived that share the same
interfaces but differ slightly in the way they operate when receiving
inputs.

The functionality recognizes a number of parties, some of which are
given the special role of administrator. Furthermore, it is
parameterized by a predicate $P(.,.)$ that determines the
\emph{precision} of the functionality, i.e., how sensitive it is to
adversarial modifications in the final tally compared to the tally
calculated based on the recorded votes. Intuitively, the $P(.,.)$
predicate captures the fact that we may implement an E2E-V procedure
via a protocol that cannot prevent, with overwhelming probability, an
adversary from switching a handful of votes. Note that absolute
precision can be achieved by setting $P(.,.)$ to be the equality
predicate; in any case we require that, for any $x$ and $y$, if $x=y$
then $P(x,y)$ holds.

These are the actions taken by the functionality.

\begin{itemize}
\item Given an ``initialization'' message in the administrator interface,
  the functionality extracts the list of eligible voters and the
  description of the ballot. It forwards the initialization message to
  the adversary. Assuming the adversary enables it to, the
  functionality verifies that the list of eligible voters is a subset
  of the list of parties it can identify and responds with success to
  the calling party. Otherwise, it responds with failure.
\item Given an ``open polls'' message in the administrator interface,
  the functionality switches its internal state to accepting votes
  after receiving permission from the adversary.
\item Given a ``cast vote'' message in the voter interface, the
  functionality extracts choices for the election's questions. Then,
  assuming that the administrator is not corrupted, the functionality
  notifies the adversary about the cast vote without communicating the
  choices of the voter; if the administrator is corrupted, the
  functionality also communicates the choices of the voter to the
  adversary. When activated, the adversary decides whether the
  functionality may respond to the voter. Given permission, the
  functionality checks that the voter is among the eligible voters and
  that the vote is valid given the election definition. If this is the
  case, it stores a record with the voter's identity and the choices
  she selected. It then requests the feedback for the voter to be
  specified by the adversary. This feedback is returned to the voter
  to signify that the ballot-casting submission has been accepted. The
  adversary is free to provide the feedback string, but the
  functionality restricts it to be unique: the adversary is not
  allowed to use the same feedback string twice. In every other
  respect, the precise structure of this string is left entirely to
  the discretion of the adversary. The feedback string is appended to
  the voter record and kept in the local state of the functionality.
\item Given a ``close polls'' message in the administrator interface,
  the functionality switches its internal state to not accept votes
  anymore after receiving permission from the adversary.  It then
  calculates the final result based on the records of the eligible
  voters who have voted. It forwards this tally, called the
  \emph{calculated tally}, to the adversary. The adversary responds
  with a possibly modified tally, called the {\em final tally}. If the
  administrator is honest, the functionality forces the final tally to
  be equal to the calculated tally regardless of what the adversary
  responds. Both the calculated tally and the final tally are recorded
  in the local state of the functionality.
\item Given a ``read tally'' message in any interface, the
  functionality requests permission from the adversary. If it receives
  permission, the functionality returns the final tally (this may be
  different from the calculated tally, if the administrator is
  corrupted). The functionality may also reveal, together with the
  final tally, the list of feedback information given to each eligible
  voter in association with the voter identities.
\item Given a ``modify voter record'' message in the adversary
  interface, the functionality extracts the voter's choice. Then,
  assuming the functionality has been notified earlier that the
  administrator is corrupted, that the polls are still open and that
  the alternate voter's choice is valid given the election's
  definition, it changes the voter's choice in the table where it
  keeps the voter records, making a note that the voter's choice has
  been changed maliciously.
\item Given a ``verify election'' record in the auditor interface, the
  functionality extracts a voter feedback string. It forwards this
  message to the adversary. If it receives permission, it attempts to
  identify the record of a voter who was given that string and return
  to the auditor a single bit signifying whether or not the original
  voter intent has been tampered with. Furthermore, it applies the
  predicate $P(.,.)$ to the calculated tally and the final tally and
  returns the output to the requestor. 
\end{itemize}

\subsubsection{Security Characteristics}

Using the template ideal functionality of the above section, we
describe how a number of required properties are captured. We examine
the properties individually.

\paragraph{Voter Privacy.}  The ideal functionality ensures voter
privacy up to a certain level by not disclosing the voter's choice
provided to the functionality in the voter interface if the
administrator is honest. We stress that voter privacy is not absolute,
since the revelation of the calculated tally to the adversarial
interface when the polls close reveals some information about the
choices of the voters. In extreme scenarios (e.g., only a single voter
casts a ballot, only a single honest voter exists among adversarial
voters, or everyone votes in the same way) no voter privacy remains
after the tally is revealed to the adversary. Naturally, no e-voting
implementation can be expected to protect privacy in these scenarios.

\paragraph{End-to-End Verifiability.} The verifiability provided by
the system is captured by the actions taken in the auditor
interface. The auditor can use the feedback provided by the system
after ballot casting to check whether the voter record has been
modified by the adversary. Observe that such a modification can happen
only if the administrator is corrupted. It is easy to see that, if all
voters audit their ballot in the auditor interface (or delegate this
task to a third party that performs it), it is guaranteed that the
$P(.,.)$ predicate holds between the calculated tally and the final
tally. In the other extreme, if nobody audits it is easy to see that
no guarantee whatsoever is given for the final tally, which may
deviate arbitrarily from the calculated tally. The intermediate
setting, where voters perform auditing with some probability, ensures
the correctness of the tally in a statistical sense. This is one of
the differences between this ideal functionality and an ideal
functionality for ``secure multiparty computation'', a standard
cryptographic notion where the output, if produced, is guaranteed to
be correct independently of the actions of the adversary.

\paragraph{Receipt Freedom.} Receipt freedom ensures that the voter
does not obtain any feedback from the system that can be used to
identify how she voted. Specifically, observe that, if the
administrator is honest, the feedback string is generated by the
adversary and is independent of voter choice. It follows that this
feedback cannot carry any voter choice information. On the other hand,
if the administrator is corrupted this property is not preserved: the
feedback may be chosen as a function of the voter's choices and
thereby violate receipt freedom. If a voter is corrupted after her
vote is cast, the template ideal functionality will not divulge the
voter record that it has stored in its local state. This points to the
fact that any implementation of the ballot casting protocol should not
leave traces from the ballot casting stage that unequivocally bind the
procedure to a specific voter choice.

\subsection{Corruption Robustness}

The ideal functionality enables the corruption of any party in the
election process. However, it keeps track of the parties that are
corrupted and provides some security guarantees even when they are
corrupted. We examine the effects of corruption from different
perspectives.

\subsubsection{Corrupt Election Administrator}

A corrupt election administrator has a dramatic effect on how the
ideal functionality operates. In the template ideal functionality, we
express the administrator of the election as a single entity. In a
protocol implementation that realizes the ideal functionality, the
administrator may be implemented by a quorum of parties/trustees who
collectively share the responsibility of the election administration.
In this case, corrupting the administrator would amount to corrupting
a sufficiently large number of trustees (the exact number is
determined by the specifics of the implementation). When operating the
ideal functionality in the presence of a malicious administrator, we
observe that privacy and receipt freedom are lost. Moreover, voter
intent as captured by the functionality can be modified by the
adversary. Despite this, the functionality still offers a faithful
auditing step and informs the auditor regarding the state of the voter
intent, as long as the auditor provides the feedback that was obtained
by the voter at the completion of ballot casting. The functionality
enforces that the feedback provided uniquely identifies each voter, so
any auditor that has proper feedback from a certain number of honest
voters is guaranteed to be able to check the status of an equal number
of voter records as preserved in the local state of the ideal
functionality.

\subsubsection{Corrupt Voters} 

A corrupt voter is a voter that is controlled by the adversary. Voters
may be corrupted at any moment, including at the onset of the system
operation and during the ballot casting process. It is expected that
an adversary controlling a certain number of voters is able to shift
an equal amount of votes in the final tally. However, the power of
such an adversary is restricted to shifting those votes, and corrupt
voters by themselves are incapable of disrupting the auditing process
or jeopardizing the privacy of the other voters.

\subsubsection{Corrupt Implementations} 

A corrupt implementation in the context of an ideal functionality is
any implementation that fails to realize the ideal functionality. If
an implementation is corrupt, this can be demonstrated via the
existence of a real world adversary such that, no matter how it is
transformed into the ideal world, there is an environment that
produces a sequence of actions that lead to a distinguishing event
between the real and the ideal worlds.

\subsection{Absent Security Properties}

The template ideal functionality does not explicitly deal with certain
security aspects. The fact that they are not directly addressed is
intentional, as their inclusion would make the security specification
substantially more complex. In this way, the template functionality
provides a baseline for security that is a minimum threshold for
end-to-end verifiability and privacy. If a scheme attains at least the
level of security suggested by the ideal functionality, it should then
be analyzed with respect to these additional properties; whether a
scheme is suitable for deployment in a certain context may depend on
whether it exhibits these additional security characteristics.

\paragraph{Denial of service attacks.} The functionality enables the
adversary to prevent voters from completing the ballot-casting
protocol, and also to prevent the tally from becoming available. From
a definitional point of view, expressing this level of security is
feasible by assuming certain qualities of the underlying communication
and message passing mechanisms employed in the implementation. One way
to extend the functionality to capture such details is to oblige the
adversary to deliver its messages by certain deadlines; in this case,
the functionality may go ahead and deliver messages via its output
interfaces without requiring the adversary to enable such messages. In
order to formally extend the functionality in this way, a notion of
time must be introduced in the model. This may be achieved by means of
a global clock functionality, relative to which deadlines can be
expressed.

\paragraph{Coercion.} Even though the functionality does not permit
coercion via the voter feedback it provides, the adversary may still
achieve coercion by corrupting a voter (e.g., hacking into the voter's
PC) and assuming her role. Extending the model to handle such coercion
is feasible by more strictly mediating the way voter corruption takes
place.

\paragraph{Sybil attacks.} The set of voters is predetermined and
integrated into the functionality. Hence, the adversary cannot
manipulate the list of voters. It follows that the functionality is
applicable to the setting where the list of voters is predetermined
and assumed to be public, and the adversary can not tamper with it.
The setting where the adversary can manipulate the system via the
introduction of fake identities in the eligible voter list is not
explicitly addressed. Nevertheless, the functionality can produce the
list of identities that have participated in voting; therefore, it is
possible for auditors to verify whether the active voters correspond
to real persons (e.g., by selecting a small random sample of them and
performing in-person interviews).

\paragraph{Privacy beyond the voters' choices.} The functionality
leaks a number of specific aspects of voter behavior to the adversary,
including the time that each voter casts their ballot and the final
list of voters who have participated in the election. As mentioned
above, this is a security feature; it enables the auditors to identify
the list of active voters and validate their participation. Increasing
privacy and reducing auditability by hiding the list of active voters
is possible in the model.

\paragraph{Accountability.} The template functionality does not
provide any mechanism to resolve disputes between a set of voters who
claim their voter records have been compromised and an election
administrator who claims that set of voters intends to disrupt the
election by making false claims. Such dispute resolution mechanisms
may be implemented judicially outside the security model, taking into
account threshold conditions; for example, if the number of complaints
is below some threshold then disputes are resolved in favor of the
election administrator (note that this will affect the verifiability
of the election in a statistical sense). However, it is also possible
to enhance the model with accountability by having the functionality
present some information about the corruption state of parties.
Currently, no such information is revealed to the auditor.

\section{Contextual Analyses of Primary E2E-V Protocols}

In this section we analyze a list of candidate e-voting systems from
the perspective of privacy and verifiability in the context of the
template ideal functionality. Further investigations will be able to
determine whether the schemes below (or close variants) are capable of
realizing some instantiation of the template ideal functionality. A
common characteristic in all the systems we list below is the
existence and general availability of a public bulletin board that
unambiguously maintains the transcript of the election. This
transcript is used by the auditors, together with feedback information
collected from the voters, to validate the election result. These are,
in some sense, minimal assumptions. If the voters are unable to have a
unique view of the election transcript, it is impossible to have
verifiability overall. The template ideal functionality would
immediately disqualify a system where an adversary can disrupt the
voters' unique view of the election transcript.

\subsection{Demos}

Demos is a system that was recently proposed by Delis et
al.~\cite{kiayias2014}. The central construction idea views the
administrator as operating in a three move protocol known as a Sigma
protocol. At the initial stage, the administrator precomputes a
sequence of encodings that contain all possible ways that a voter can
vote in an election and posts them on a public bulletin board. The
administrator then distributes ballots that enable voters to cast
their votes by essentially pointing to specific encoded information on
the bulletin board. The election terminates by having the
administrator post a proof to the bulletin board showing that the
tally computation is correct.

A key feature of the system is that the administrator precomputes for
each voter two equivalent ways to cast a ballot, and the voter is free
to choose one of the two (say, ``A'' or ``B'') at random. While the
A/B decision does not affect how the voter interacts with the system,
it introduces voter-side entropy that is independent of the voter's PC
or device and can be collected and used to ensure the calculation of
the tally is correct. Taking advantage of this feature, DEMOS is
capable of producing a proof that unequivocally ensures the result is
correct, without having to rely on any additional assumption beyond
the availability of the election transcript and the feedback from the
voters.

From the implementation point of view, the voter interface requires
the ballot encoding information. Given this information, ballot
casting is straightforward as it only requires submitting the
corresponding pointer to the bulletin board. Note that the pointer
itself does not violate the privacy of the voter, since it merely
points to an ciphertext that hides the actual choice under a
cryptographic computational assumption (specifically, a variant of the
Decisional Diffie Hellman assumption).

The verifiability of the system hinges on the fact that the election
administrator will have to prove that the tally is correct by opening
any of the unused ballot encodings on the bulletin board. In order to
attack verifiability effectively, the administrator will have to guess
the choices made by the voters in the A/B decision. While this may be
feasible for just a handful of voters, Delis et al. show that the
probability of not getting caught drops exponentially in the distance
of the deviation of the final tally from the calculated tally (in our
present terminology).

Demos (or a Demos variant) has the potential to realize some useful
instantiation of the template ideal functionality given the proof
arguments presented by Delis et al., assuming there is sufficient
entropy in the A/B decision performed by the voters.

\subsection{Helios}

Helios~\cite{adida2008} culminates a long sequence of previous works
that used client side encryption combined with a ciphertext processing
stage that breaks the connection between the identity of the voter and
her choices during ballot casting. The voter casts a ballot by using a
public-key encryption operation under a key that is provided by the
election administrator. This key is typically generated by a quorum of
trustees, who collectively control the decryption operation under a
certain threshold condition.

The verifiability features of such a system are based on two
mechanisms. First, the voter is allowed to challenge her client side
encryption device (a PC, smartphone or other system). This is
performed when the device has produced a ciphertext; the voter is
asked whether to cast it or audit it. In case of an audit, the choices
used for producing the ciphertext are presented and the voter obtains
a transcript of information that can be used to verify that the
ciphertext is properly constructed. Note that such information cannot
be verified visually or by hand, and the voter is required to keep
this information and verify it using a second device; in order for the
check to be meaningful, this auditing device should run code that is
independent from the voter's main device. After the voter has
performed a number of audits and kept the results she can cast her
encrypted ballot, which is posted to the public bulletin board. With
each ciphertext that is produced, ``smart ballot tracker''
information--- a hash of the ciphertext---is provided. This can be
used by the voter to verify that the ciphertext that was generated is
the same one that appears on the bulletin board.

Helios utilizes non-interactive zero-knowledge (NIZK) proofs for (i)
ensuring that the encrypted votes are of the proper form, and (ii)
ensuring that the decryption is performed properly by the
trustees. The presence and verification of those NIZKs is essential
for the verifiability and privacy aspects of the system.

Overall, auditing in Helios requires (i) the verification of the
artifacts of the cast-or-audit process, (ii) checking that the smart
ballot tracker corresponds to the hash of the ciphertext that is
posted to the bulletin board, and (iii) verifying the zero-knowledge
proofs that ensure the encrypted ballots are properly encoded and the
ciphertext processing is properly executed.

The current implementation of Helios utilizes encryption with an
additive homomorphic property, so that vote tallying can be executed
over the submitted ciphertexts. An alternative implementation that
utilizes mix-nets for ciphertext processing has been proposed
\cite{tsoukalas2013}.

Helios (or a Helios variant) has the potential to realize some useful
instantiation of the template ideal functionality; it can satisfy
end-to-end verifiability assuming the voters perform the
audit-or-check procedure following a probabilistic strategy. Note that
that such a proof will require the validity of the NIZK components,
which in the present system formulation relies on an abstraction
called the random oracle model.

\subsection{Norwegian System}

The Norwegian system \cite{gjosteen2012} is based on a protocol
developed by Scytl. The administrator generates for each voter a list
of receipt codes, one for each possible choice. These are communicated
to the voters ahead of time. The voters submit their encrypted votes
to the administrator. Using a special ciphertext processing operation,
it is possible for the administrator to extract from each ciphertext
the code that corresponds to the choice of the voter and submit it
back to the voter via an independent channel (e.g., if voting takes
place using a PC the code can be transmitted back to a smartphone).
This arguably assures the voter that the system has correctly recorded
her intent without violating her privacy. The reason is that the code
itself is pseudorandomly dependent on the choice of the voter and
independently selected for each voter. Thus, the code by itself
reveals no useful information about the choice of the voter. At the
same time, the ciphertext processing step ensures that the server
calculating the code has to apply the proper function and extract the
proper value, and it is hard for the server to guess an alternative
value given the pseudorandomness of the codes.

When the voter receives the code she can compare it with the
information that is available to her and verify that the system
correctly recoded her intention.

Contrary to Helios or Demos, verifiability in this system is only
guaranteed if the adversary does not control both the servers and the
device used by the voter to cast the ballot. If the adversary does
control both, it can deceive the voter into thinking that the proper
choice has been recorded when something else has been recorded
instead. It follows that the verifiability guarantee for the Norwegian
system is weaker than for Demos or Helios. Note that the template
functionality can accommodate such weaker guarantees by suitably
restricting the number and type of corrupt parties in the real
execution; nevertheless, it would be preferable to avoid such
restrictions if possible.

\subsection{Remotegrity}

Remotegrity \cite{zagorski2013} is a front-end system for Internet
voting that can be combined with a back-end system (such as
Scantegrity-II \cite{chaum2008scantegrity}) to offer a complete
e-voting system with end-to-end verifiability guarantees.

During initialization, the system administrator precomputes a number
of encoded ballotsand commits to a properly formed set of tables of
commitments in a public bulletin board. For each candidate choice, a
unique vote code is assigned to each voter; the tables commit to a
correspondence between vote codes and candidates. During the cast
protocol the voter can select to audit or cast a vote. Audited ballots
are spoiled, and their correspondence in the tables is revealed at the
end of the election process. Cast ballots, on the other hand, record a
certain vote code and the corresponding election choice is later
revealed in a way that keeps the correspondence to the voter hidden.

This is achieved via the interaction of two tables of commitments that
become partially open, depending on a source of public and verifiable
randomness.

Assuming that the adversary is incapable of biasing the independent
random source that provides the challenge for the partial opening of
the commitment tables, it is possible to argue that the system
satisfies a level of verifiability without sacrificing privacy.

Based on this, the system has the potential for privacy and
verifiability only in case of an adversarial environment where the
randomness used to challenge the administrator remains unbiased and
outside the control of the adversary. It is easy to see that, if the
adversary completely controls the randomness used in the challenge
stage, it can produce any tally regardless of voter intent.

Several natural or human public phenomena have been proposed for
providing randomness in this context; for example, stock market
end-of-day quotes and weather measurements are potential candidates.
However, using such sources of randomness is not straightforward
because the randomness quality is limited and uniform randomness must
be extracted properly.

\subsection{RIES}

The Rijnland Internet Election System (RIES)~\cite{gonggrijp2009} was
used from 2004 to 2006 for elections in Dutch District Water Boards,
and in 2006 for Dutch expatriates in the parliamentary elections. RIES
is simpler than the systems examined above.

The administrator produces a public-key encryption pair and one
symmetric encryption key for each voter. Subsequently, voters can
submit vote codes that are calculated as functions of their symmetric
encryption key. The administrator, who knows all symmetric encryption
keys, publishes a table of hashes on the vote codes used by the
voters. A voter interacts with her device, providing the symmetric
encryption key. The device prepares the vote code (which is computable
using the encryption key) and maintains that vote code as a receipt
for the voter. Meanwhile, the administrator decrypts all votes and
posts them to a public bulletin board in some predetermined order that
also depends on the symmetric encryption key.

It is possible to calculate the final tally using the information that
posted to the bulletin board, by matching it with the hashed vote
codes. However, the system produces receipts that unequivocally
identify voter intent during ballot casting. Indeed, the system is not
receipt free and therefore cannot be used as a reasonable
implementation of the ideal functionality.

\subsection{Wombat}

The Wombat system~\cite{ben2012new} falls in the same category as
Helios and Zeus, with the exception that it uses an on-site ballot
casting setup that also preserves the original voter intent on paper.
The voters generate ciphertexts with the aid of a device with a
printer, which presents the voter choice in both ciphertext and
plaintext forms. The voter may choose to audit the combination using
the same technique as the Helios audit-or-cast mechanism. When the
voter decides to cast the ballot, she tears the plaintext part and
places it in a ballot box. The ciphertext part is scanned and posted
to a public bulletin board. The voter retains the encoding of the
ciphertext that was cast as a fingerprint to match it with the
information on the bulletin board.

In order to preserve the privacy of the voters, a mix-net final step
is employed to ensure that ciphertexts become disassociated from the
voters who cast them. Overall the same verifiability and privacy
arguments made in the case of Helios apply here (taking into account
the fact that Wombat is an on-site system).

\newcommand{\PaV}{Pr{\^{e}}t {\`{a}} Voter\xspace}

\subsection{vVote/\PaV}

The vVote system is an adaptation of the \PaV system for the
Australian state of Victoria elections \cite{culnane2014vvote}. It
retains the general structure of \PaV \cite{ryan2009} while modifying
the way the encryption of voter choices is performed to suit the style
of elections in Victoria.

\PaV paper ballots are divided into a left- and right-hand side. Each
ballot contains a permutation of the choices that are available to the
voter. The voter is invited to enter her choices on the right-hand
side while the names of the candidates appear (randomly permuted) on
the left-hand side. After marking, the left-hand side is destroyed
while the right-hand side is scanned; it is posted on a public
bulletin board and kept as a receipt. The right-hand side also
contains an encryption of the permutation used in the ballot.

Verifiability can be based on an audit-or-cast process on the printed
ballot and verification of the process on the bulletin board.
Specifically, the voter can choose to spoil a ballot and reveal the
encryption of the permutation, which will enable the comparison of the
encrypted permutation to the one physically shown on the the ballot.
The voter can also track her ballot on the bulletin board, since the
right hand side contains an encoding of the ciphertext. Finally, the
result is revealed after a mix-net operation that includes
zero-knowledge proofs to ensure that the mixing process is done
correctly (namely, no ballots are substituted or removed at each
mixing step).

In principle, the logic under which verifiability can be argued for
vVote/\PaV is similar to that for Helios and Wombat.

\section{Realizing Ideal Functionality}

In this section we describe some general directions and tools
regarding realization of the ideal functionality. We start by
introducing relevant cryptographic tools and continue to describe how
it is possible to mechanize the security proof of realizing the ideal
functionality. We also present a case study for one system, and make
the case for open protocols and software independence.

\subsection{Commonly Used Cryptographic Tools}

A number of cryptographic tools play an important role in the design
of e-voting schemes. We present some of these tools, which have been
used in the designs of the systems discussed in the previous section.

\paragraph{Commitment.} A \emph{(non-interactive) commitment}
  scheme is comprised of two algorithms
$(\mathrm{Commit}, \mathrm{Verify})$, and enables a party to produce a
pair $(\psi, \rho) \leftarrow \mathrm{Commit}(m)$ so that $\psi$
``commits'' to the value $m$ without revealing much information about
$m$. Specifically, a party can commit to $m$ by sending $\psi$ to a
public bulletin board. At a later time, the party can reveal $m,\rho$
and any other interested party can verify that the process was done
correctly by running the algorithm $\mathrm{Verify}(\rho, m, \psi)$.
The two algorithms may be parameterized by a public parameter $p$ that
is available to all parties. In this case, another algorithm that
generates the parameter $p$ may be added to the description. Depending
on the type of commitment, this algorithm may be required to be
executed honestly. The security model requires that commitments are
\emph{hiding}, i.e., $\psi$ does not reveal any information about $m$,
and \emph{binding}, i.e., it is infeasible for the party that makes a
commitment to $m$ to equivocate it and reveal a different value $m'$.

\paragraph{Public-key encryption.} A \emph{public-key encryption} is
comprised of three algorithms
$(\mathrm{Gen},\mathrm{Enc}, \mathrm{Dec})$. The algorithm
$\mathrm{Gen}$ produces a pair of public and secret key, denoted by
$(pk,sk)$. Algorithm $\mathrm{Enc}(pk, \cdot )$ applied to input
plaintext $m$ returns a ciphertext $\psi$ that corresponds to $m$.
Algorithm $\mathrm{Dec}(sk, \psi )$ returns the plaintext that
corresponds to the input $\psi$. The security model requires at
minimum that an adversary, given the public-key $pk$, is incapable of
distinguishing between two ciphertexts that correspond to different
plaintexts even if such plaintexts are adversarially chosen.

\paragraph{Additively homomorphic encryption.} A \emph{homomorphic
  (public-key) encryption} scheme adds the following property to the
$\mathrm{Enc}(pk, \cdot)$ algorithm. First, the space of plaintexts is
given a group structure over a binary addition operation $+$. Then,
given $\psi_1 = \mathrm{Enc}(pk, m_1)$ and
$\psi_2 = \mathrm{Enc}(pk, m_2)$, it is possible to compute a
ciphertext $\psi$ that corresponds to an encryption
$\mathrm{Enc}(pk, m_1 + m_2)$. Furthermore, we also require that if at
least one of $\psi_1, \psi_2$ is sampled uniformly over all
ciphertexts, the output $\psi$ follows the uniform distribution over
all ciphertexts of $m_1 + m_2$.

Additive homomorphic encryption enables processing of ciphertexts in
various ways that are useful in e-voting systems. Two important uses
of such schemes are as follows: (i) Given $k$ ciphertexts
$\psi_1, \ldots, \psi_k$ encoding $v_1, \ldots, v_k \in \{0,1\}$, it
is possible to derive a single ciphertext $\psi$ that encodes
$T= \sum^k_{i=1} v_i$. Such a $T$ can be used to derive the tally of
an election if each plaintext $v_i$ corresponds to an election choice
made by the $i$-th voter. (ii) Given $\psi = \mathrm{Enc}(pk, m)$ it
is possible to ``refresh'' the randomness of $\psi$ by processing
$\psi$ together with $\mathrm{Enc}(pk, 0)$. The resulting ciphertext
is uniformly distributed over the ciphertexts encoding $m$.

\paragraph{Secret-sharing.} A \emph{secret-sharing} scheme is
comprised of two algorithms $(\mathrm{Gen}, \mathrm{Rec})$ that
operate as follows. Given parameters $(n,t)$ and a value $s$, the
algorithm $\mathrm{Gen}$ produces $n$ ``shares'' $s_1, \ldots, s_n$.
The algorithm $\mathrm{Rec}$, given any subset of size at least $t$
from the set $\{s_1, \ldots, s_n\}$, reconstructs the value $s$. The
security guarantee that we require for a secret-sharing scheme is
that, if the adversary has any set of size less than $t$ values from
$s_1,\ldots, s_n$, it should be incapable of finding any non-trivial
information about $s$. The value $t$ is called the \emph{threshold} of
the secret-sharing scheme.

An additional property for secret-sharing schemes is verifiability,
where the reconstruction algorithm is capable of detecting shares that
are incorrect based on some public information provided by the
$\mathrm{Gen}$ algorithm.

\paragraph{Threshold encryption.} A \emph{threshold (public-key)
  encryption} is equipped with a multiparty protocol that implements
the $\mathrm{Gen}()$ public/secret key generation algorithm among a
set of parties. Specifically, this protocol is parameterized by two
integers $(t,n)$ and enables a set of $n$ parties (sometimes called
trustees) to produce the value $pk$ as well as a secret-sharing of the
value $sk$ with threshold $t$. The shares of the secret key $sk$ are
kept by the trustees and can be revealed when it is time to decrypt a
ciphertext.

A threshold encryption scheme is also capable of achieving threshold
decryption if there is a protocol that implements the algorithm
$\mathrm{Dec}()$ so that each trustee uses her own share of the
secret-key $sk$ but is not required to reveal it. Threshold decryption
is particularly important in practice, since it is typically desirable
to apply the decryption function $\mathrm{Dec}$ selectively only to
specific ciphertexts that may be identified by the system that
utilizes threshold encryption.

The property required by a threshold encryption is similar to that of
secret-sharing. The adversary should be incapable of finding any
information about a target ciphertext if it controls less than $t$
trustees. Importantly, the adversary should be incapable of doing so
despite the fact that it may be participating in various threshold
decryption operations running concurrently on ciphertexts other than
the target ciphertext.

\paragraph{Zero-knowledge proofs.} A \emph{zero-knowledge (ZK) proof}
is a protocol between two parties, called the prover and the verifier,
that is associated with a language
$L = \{x \mid \exists w : R(x,w)\}$, where $R$ is a polynomial-time
predicate in a parameter $k$ and $x$ and $w$ are strings of length
$k$. The protocol enables the prover to convince the verifier that she
is in possession of a ``witness'' $w$ regarding the fact that
$x\in L$.

The properties required by a ZK proof are completeness, soundness and
zero-knowledge. Informally, completeness requires that the verifier
accepts an honest prover, soundness expresses that the prover cannot
cheat (e.g., that she cannot convince the verifier if she does not
know the witness) and zero-knowledge that the verifier cannot learn
anything significant about $w$ from interacting with the prover beyond
the fact that $x\in L$. Sometimes it may be the case that $x\in L$ is
a given fact and the protocol has the objective to demonstrate that
the prover is in possession of the witness $w$. Protocols with this
property are called ZK proofs of knowledge.

An important variation of ZK proofs are non-interactive ZK (NIZK)
proofs, where the prover is capable of producing a string $\pi$ in one
move that by itself can convince the verifier regarding the status of
the statement $x\in L$ (or that the prover is in possession of the
witness $w$). A NIZK requires a public parameter $p$ that should be
honestly produced (independently of the prover and the verifier).

\paragraph{Mix-nets.} A \emph{mix-net} is a protocol executed
sequentially by a set of servers on a set of ciphertexts that
originate from a public-key encryption scheme. Specifically, a mix-net
can be built upon a single algorithm $\mathrm{Shuffle}()$ that is
given the public-key $pk$ as well as a sequence of ciphertexts
$\vec\psi = (\psi_1,\ldots, \psi_n)$. The algorithm produces a
sequence of ciphertexts $\vec\psi' = (\psi_1', \ldots, \psi'_n)$ as
well as a ``proof'' $\pi$. The proof $\pi$ can be in the form of a
NIZK that ensures the following fact about the values
$(pk, \vec \psi, \vec \psi')$. Let $M$ be the sequence of plaintexts
that in the $i$-th position is equal to
$ \mathrm{Dec}(\psi_i) \rangle$, and similarly $M'$ the sequence of
plaintexts that in the $i$-th position is equal to
$\mathrm{Dec}(\psi_i') \rangle$. It should hold that there is a
permutation $\mu$ over $n$ elements such that the $j$-th element of
$M$ is equal to the $\mu(j)$ element of $M'$ for all $j=1,\ldots, n$.

Given the $\mathrm{Shuffle}()$ algorithm, observe that we can apply it
sequentially on the same sequence of ciphertexts. If a sequence of $m$
servers apply $\mathrm{Shuffle}()$ one after the other, it is easy to
see that the correspondence between the original sequence of
ciphertexts and the final sequence of ciphertexts will be hidden
provided that at least one server remains honest.

\subsection{Other Potentially Useful Cryptographic Tools}

There are several other cryptographic tools that have not yet seen
much application in the context of E2E-V protocol design. Several are
briefly summarized here, in part because they represent opportunities
for novel research directions in E2E-V protocol design. They also
described because some naive proposals for election systems include
the use of these tools, and should be identified and rejected.

\paragraph{Hashchains and blockchains.} A \emph{hashchain} is a data
store that holds a ledger of sequential records in a cryptographically
secure fashion~\cite{Haber90}. Hashchains are commonly used to record
a sequence of causally dependent events with cryptographic integrity
and non-repudiation. Within the context of election systems,
hashchains are a common means of recording privacy-preserving election
logs for post-election audit, constructing digital ballot boxes,
crafting public bulletin boards that contain evidence of an election's
correctness and security properties, and more.

A hashchain $H$ is constructed by the repeated application of a
cryptographic hash function $h$. Linear hashchains are of the form
$H^{k}=h(x_{k} \otimes h(...h(x_{2} \otimes h(x_{1} \otimes h(\perp
\otimes \perp)))))$
where each (identical) hash $h$ is applied to a fusion $\otimes$
(often defined as xor) of the previous hashchain and a new ledger
element $x$. The bottom element $\perp$ can be one of a number of
potential root values (e.g., a prefix of the public key of a given
election), depending upon the context of the application of the
hashchain. 

\emph{Non-linear hashchains} are trees of linear
hashchains~\cite{Benaloh91,Bayer93}. They are useful in the context of
disconnected devices with causally or temporally connected ledgers
(e.g., disconnected machines used in a given election).

A \emph{blockchain} is a distributed data store that holds a ledger of
transactions in a cryptographically secure fashion. It is a kind of
distributed hashchain, where multiple computers compute and
communicate to determine the next data element of the hashchain/tree
using a consensus protocol. Blockchains often rely upon a
cryptographic work factor to determine consensus and to prevent
manipulation of the ledger by powerful adversaries; the most publicly
visible example of a blockchain that works in this way is the Bitcoin
blockchain.~\cite{Bitcoin}

Proposals to use blockchains for elections are plentiful, but have
been shown to be na\"{i}ve in most instances and inappropriate as a
foundation for a public election E2E-V protocol. The only reasonable
proposal for the use of blockchains for parts of an election protocol
is from Clark and Essex~\cite{clark2012commitcoin}.

\paragraph{Multi-party computation and linear secret sharing.}
\emph{Secure multi-party computation} (MPC) is a collaborative
privacy-preserving computation technology. MPC permits a (typically
small) collection of parties to compute a collaborative result without
any party gaining any knowledge about the inputs provided by other
parties, except for what can be determined from the output of the
computation~\cite{chaum1988multiparty, goldwasser1987play}.

Since the computation takes place on encrypted data, it can be
performed on public systems (such as in a public cloud
infrastructure). Moreover, since systems can communicate using a
public protocol to compute collaboratively, parties to the computation
can be implemented by multiple cooperating or competing organizations.

In the kind of MPC known as \emph{linear (or additive) sharing},
computation proceeds on data that appears entirely
random~\cite{Cramer00}. Certain operations, such as addition or
logical exclusive OR, can be performed locally; however, operations
such as multiplication and logical AND require network communications
among the parties. Consequently, the computational overhead of MPC is
large, and MPC is orders of magnitude slower than computing on
unencrypted data.

However, efficiency improvements over the last few years have shifted
the potential applicability of MPC from micro-benchmarks to user-level
applications, including some that have a data volume comparable to
elections. Consequently, there may be real opportunities to use MPC
for E2E-V elections.

\paragraph{Functional encryption.} \emph{Functional encryption} (FE)
is a kind of public-key cryptography in which possessing a secret key
permits one to learn a function of what the ciphertext is encrypting,
and nothing more~\cite{boneh2011functional}.

More precisely, a FE scheme for a given functionality $F$ consists of
the following four algorithms:
\begin{enumerate}
\item $(pk, msk) \leftarrow Setup(1^\lambda)$: creates a public key
  $pk$ and a master secret key $msk$;
\item $sk \leftarrow Keygen(msk, k)$: uses the master secret key to
  generate a new secret key $sk$ for value $k$;
\item $c \leftarrow Enc(pk, x)$: uses the public key to encrypt a
  message $x$; and \item $F(k, x) \leftarrow Dec(sk, c)$: uses secret
  key $sk$ to calculate a function of the value $c$ encrypts.
\end{enumerate}

FE's primary use is in encrypted databases whose security properties
are determined, in part, by the computations permitted on their
encrypted data~\cite{Popa11}. Consequently, FE may prove useful in
storing, or computing on, election data such as ballots and audit
logs.

FE encryption generalizes several existing primitives, including
\emph{identity-based encryption} (IBE) and \emph{attribute-based
  encryption} (ABE), both of which may be useful in the context of
authentication in E2E-V
protocols~\cite{shamir1985identity,goyal2006attribute}.

\paragraph{Fully homomorphic encryption.} \emph{Fully homomorphic
  encryption} (FHE) is a more powerful type of homomorphic encryption
than those previously mentioned. FHE permits arbitrary computation on
encrypted data, but is prohibitively slow (several orders of magnitude
slower than unencrypted computation) and requires enormous ciphertexts
(dozens to hundreds of megabytes in size).

It is unclear whether FHE has potential application in the context of
E2E-V protocols. However, given increasing interest in FHE and the
availability of open source implementations of FHE libraries, it is
likely to applied in the context of cloud deployments of election
systems.

\paragraph{Verifiable computing.} \emph{Verifiable computing} is a new
area of research and development that focuses on the offloading of
computation to an untrusted system (for example, an untrusted e-voting
machine or a cloud hosting service) while still having a means by
which to check that the computation was performed correctly.

Several technologies exist to help verify that a computation performed
by untrusted workers is correct, including the use of secure
coprocessors, Trusted Platform Modules (TPMs), interactive proofs, and
more~\cite{king2013trusted,perez2006vtpm,sparks2007security}. These
are either interactive verifications, which require the client to
interact with the worker to verify the correctness proof, or are
non-interactive protocols that can be proven in the random oracle
model.

The utility of verifiable computing in the context of E2E-VIV is
obvious, but the state of the art is still far from being able to
handle the data volumes mandated by public elections. It is to be
expected that new results in verifiable computing, and E2E-V protocols
that presume the existence of efficient verifiable computing, will be
forthcoming.

\section{Formal Mechanization of Ideal Functionality}
\label{sec:crypto_mechanization}

As mentioned above, in order to contextualize E2E-V protocol designs
and especially to objectively compare and contrast them, the ideal
functionality must be mechanized.

The premiere environments in which to perform such mechanization are
Coq~\cite{Coq}, EasyCrypt~\cite{EasyCrypt},
CryptoVerif~\cite{CryptoVerif}, and Cryptol~\cite{Cryptol}. Each has
pros and cons, and it is certainly reasonable to consider mechanizing
protocols and their dependent algorithms in multiple environments. In
general, any framework chosen must be trusted by cryptographers, be
open source, and have liberal licensing terms.

There are several other excellent useful environments that should be
considered for future mechanization work, including higher-order
frameworks such as PVS~\cite{PVS}, Isabelle~\cite{Isabelle}, and
HOL~\cite{HOL}, and protocol-centric tools such as F*~\cite{Fstar},
CVK~\cite{CVK}, and ProVerif~\cite{ProVerif}, which we will not
describe in detail here.

\paragraph{Coq.} Coq is a general purpose logical framework based upon
the Calculus of Inductive Constructions. It has a small trusted core,
proofs are first-class constructs, and several libraries are available
for reasoning about not only cryptographic algorithms and protocols,
but also the correctness of programs written in a variety of
languages. A significant amount of recent research focusing on the
verification of cryptographic algorithms and protocols has used Coq,
including Princeton's work on formally verifying SHA and HMAC,
Harvard's work on reasoning with the Foundational Cryptography
Framework, and IMDEA's early work on their precursor to EasyCrypt,
CertiCrypt.

\paragraph{EasyCrypt.} EasyCrypt is a toolset for reasoning about
relational properties of probabilistic computations with adversarial
code. Its main application is the construction and verification of
game-based cryptographic proofs. Initial applications of EasyCrypt
focused on encryption and signature schemes, but recent extensions
reason about the security of cryptographic systems that achieve
specific functionalities through intricate combinations of several
primitives. These developments have significantly expanded the scope
of potential applications of EasyCrypt, as reflected in the recent
formalization of secure function evaluation and verifiable
computation. Moreover, they have enabled the formalization of examples
that were previously out of scope, for instance modular proofs of
security for key-exchange protocols and E2E-V protocols like Helios.
EasyCrypt was custom-designed by Barthe and his colleagues at IMDEA
and INRIA.

\paragraph{CryptoVerif.} CryptoVerif is a computationally sound
mechanized prover for cryptographic protocols created by Blanchet and
his collaborators. It has been used to reason about the secrecy and
correspondence properties of numerous protocols and gives a bound on
the probability of any attack.

\paragraph{Cryptol.} Cryptol is a domain-specific language for
specifying cryptographic algorithms. A Cryptol implementation of an
algorithm resembles its mathematical specification more closely than
an implementation in a general purpose language. Using a specification
in Cryptol, programmers can generate their own test vectors, prove
theorems, and (using other tools) verify equivalence to their own
programs, or even generate code or hardware from the specification.

\subsection{Recommendations}

Based upon our experience, a promising approach would be to use Coq to
formalize systems and reason about implementations written in C (using
CompCert and VST), Cryptol to specify cryptographic algorithms and
simple protocols and reason about their correctness and their
implementations' (in LLVM or JVM), EasyCrypt to reason about
algorithms' and protocols' security properties, and F* to specify and
reason about protocols that need a Javascript or .Net implementation.

\section{Specification of Open Protocols} 

E2E-V protocols, while cryptographic protocols, are at their core just
protocols. They specify the means by which different subsystems
communicate with each other. If we presume that different subsystems
may be implemented by different parties, and that multiple independent
implementations of critical components (such as tabulation and
verification subsystems) are mandatory, then the precise specification
of open protocols is critical.

The best practice for protocol specification is to formalize the
protocol using a precise mechanization, provide a reference
implementation, and provide a means by which any implementation can be
validated against the specification. Given the aforementioned
toolsets---ProVerif, EasyCrypt, CryptoVerif, and F*---specifying the
protocols is straightforward. Verifying the protocols' correctness and
security properties is a much more challenging, though not
insurmountable, proposition.

The real challenge is in verifying an implementation's correctness.
Full blown formal verification of implementations, while possible,
takes a significant amount of effort, typically several man-months of
work. Moreover, if a specification is not written with the intention
of supporting a protocol under evolution, re-verifying changes in a
protocol implementation can require as much effort as the original
verification.

Rigorous validation of a protocol, on the other hand, takes
significantly less effort and is more flexible in the face of protocol
evolution. Recent work from Cambridge focusing on the rigorous
specification and implementation of TLS~\cite{nqsb-TLS} in a pure
functional style exemplifies the kind of reference implementation that
should be written for an E2E-V protocol.

\section{The Case for Software Independence}

A voting system is software independent if an undetected change or
error in its software cannot cause an undetected change or error in an
election outcome. One way to achieve software independence is to endow
the voting system with the capability to record voter intent
physically in a way that is immediately verifiable by the voter at the
time of ballot casting. Given such a record, one would subsequently
perform a random audit to ensure that the published election outcome
(generated by software) does not deviate from the result that would
have been calculated if the physical record was used in the tallying
process.

A notable example of such a procedure currently in place is in the
state of Connecticut, where optical scan voting machines are used. The
marked paper ballots are retained after the election in each precinct.
After the end of the election when the tally is announced, a sample of
precincts is randomly selected at the state level and a manual hand
count is performed. The results of the hand count are audited and a
statistical analysis is conducted to confirm the e-voting tally at a
certain confidence level. Antonyan et al.~\cite{antonyan2009state}
provide more details regarding this audit procedure.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "report"
%%% End:
